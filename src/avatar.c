/* ========================================================================= */
/* File: avatar.c - the avatar program for the Amazing Project
 *
 * Author: Gabriel Corso, Tyler Crowe, Joanne Zhao
 * Date: May 18, 2014
 *
 * Input:
 * ./avatar [AvatarId] [nAvatars] [Difficulty] [IPAddress] [MAZEPort] [LogFile]
 * [MazeWidth] [MazeHeight]
 *
 * [AvatarId]
 * An integer generated by AMStartup, starting at 0 and incremented by 1 for 
 * each subsequent Avatar generated
 *
 * [nAvatars]
 * An integer greater than or equal to 2 and less than or equal to 10. This
 * represents how many Avatars total in the maze
 *
 * [Difficulty]
 * An integer greater than or equal to 0 and less than or equal to 9. This 
 * number determines the size of the maze and the max number of moves allowed.
 *
 * [IPAddress]
 * This is the IP Address of the server.
 *
 * [MazePort]
 * This value is returned from AM_INIT_OK and is the port number for the 
 * generated maze. 
 *
 * [LogFile]
 * Filename of the log the Avatar should open for writing in append mode. In 
 * the format AMAZING_<USERNAME>_<nAvatars>_<Difficulty>.log
 *
 * [MazeWidth]
 * Width of the mze
 *
 * [MazeHeight]
 * Height of the maze
 *
 * Command line options: None
 *
 * Output: The avatar program writes information to both the log file and the 
 * console while running. 
 * The log file will include the moves made by the avatars. When the maze is
 * completed, the log file will include a line by one of the avatars confirming
 * that the maze has been solved.
 * A graphical visualization is also displayed using ASCII.
 *
 * Error Conditions: any invalid arguments, unable to connect to server
 *
 * Special Considerations:
 *
 */
/* ========================================================================= */
// ---------------- Open Issues

// ---------------- System includes e.g., <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <string.h>
#include <netdb.h>
#include <inttypes.h>
#include <iso646.h>

// ---------------- Local includes  e.g., "file.h"
#include "amazing.h"
#include "maze.h"
#include "functions.h"
#include "graphics.h"

// ---------------- Constant definitions

// ---------------- Macro definitions

// ---------------- Structures/Types

// ---------------- Private variables
char *progname;                // program name, i.e. avatar
int avatarID;                  // the ID of the avatar
int nAvatars;                  // number of avatars
int difficulty;                // difficulty of the maze
char *hostName;                // the host name
char *IPAddress;               // the IP address
char *fileName;                // file name for the log file
uint32_t mazePort;             // the maze port
int mazeWidth;            // width of the maze
int mazeHeight;           // height of the maze
AM_Message messageToServer;    // message to be sent to the server
AM_Message messageFromServer;  // message to be received from the server
int blocked;
int calculatedMove = 0;
int deadend = 0;
int firstMove = 1;
int master; // the master avatar
int stuck = 0;

// ---------------- Private prototypes

/* ========================================================================= */

int main(int argc, char **argv) 
{
  

  progname = argv[0];
  
  /* Check the arguments */
  if (argc != 9) {
    perror("Usage: ./avatar [AvatarId] [nAvatars] [Difficulty] [IPAddress] [MAZEPort] [LogFile] [MazeWidth] [MazeHeight]");
    exit(1);
  }

  /* since the avatar is not meant to be run by a human, milder tests are used
     to validify the parameters */

  nAvatars = atoi(argv[2]);
  if(nAvatars < AM_MIN_AVATAR || nAvatars > AM_MAX_AVATAR ){
    perror("Invalid number of avatars. Must be between 2 and 10, inclusive");
    exit(1);
  }

  avatarID = atoi(argv[1]);
  if(avatarID < 0 || avatarID > nAvatars){
    perror("Invalid avatar ID. Must be within the bounds of the number of avatars");
    exit(1);
  }

  difficulty = atoi(argv[3]);
  if(difficulty < 0 || difficulty > AM_MAX_DIFFICULTY ){
    perror("Invalid difficulty. Must be between 0 and 9, inclusive");
    exit(1);
  }

  IPAddress = argv[4];

  mazePort = atoi(argv[5]);

  fileName = argv[6];

  mazeWidth = atoi(argv[7]);
  if(mazeWidth < 0 || mazeWidth > MAX_WIDTH){
    perror("Invalid maze width");
    exit(1);
  }

  mazeHeight = atoi(argv[8]);
  if(mazeHeight < 0 || mazeHeight > MAX_HEIGHT){
    perror("Invalid maze height");
    exit(1);
  }

  printf("Avatar created with AvatarId %d of %d\nDifficulty %d, IPAddress %s, MAZEPort %d, Log file %s, Maze Width %d, Maze Height %d\n", avatarID, nAvatars, difficulty, IPAddress, mazePort, fileName, mazeWidth, mazeHeight);

  /* creation of the socket */

  int sockfd;
  struct sockaddr_in servaddr;

  //Create a socket for the client
  //If sockfd<0 there was an error in the creation of the socket
  if ((sockfd = socket (AF_INET, SOCK_STREAM, 0)) <0) {
    perror("Problem in creating the socket");
    exit(2);
  }

  //Creation of the socket
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr= inet_addr(IPAddress);
  servaddr.sin_port = htons(mazePort); //convert to big-endian order
  
  //Connection of the client to the socket 
  if (connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr))<0) {
    perror("Problem connecting to the server");
    exit(3);
  }

  /* set up the AVATAR READY message */

  messageToServer.type = htonl(AM_AVATAR_READY);
  messageToServer.avatar_ready.AvatarId = htonl(avatarID);
  
  send(sockfd, &messageToServer, sizeof(messageToServer), 0);
  
  if(ntohl(messageToServer.type) == AM_AVATAR_READY){
    printf("Sent AM_AVATAR_READY signal with AvatarID: %d\n", ntohl(messageToServer.avatar_ready.AvatarId));
    char *readyLogLine = calloc(strlen(fileName) + 100, sizeof(char));
    snprintf(readyLogLine, strlen(fileName) + 100, "echo -ne \"\nSent AM_AVATAR_READY signal with AvatarID: %d\" >> %s", avatarID, fileName);
    system(readyLogLine);
    free(readyLogLine);
  }

  int turns = 0; // keep track of all turns
  XYPos prevXY; // previous position
  XYPos currXY; // current position
  uint32_t prevDir; // previous direction
  XYPos masterXY; // master avatar's postion
  MazeNode *shmaze; //shared maze
  int shmid;
  int shmid2;
  int *trail; // paths in the shared maze
  // shared memory id creation
  if((shmid = shmget(SHMKEY, sizeof(MazeNode)*mazeWidth*mazeHeight, IPC_CREAT | 0666)) < 0 ){
    printf("avatar shmget1 %d\n", avatarID);
    perror("shmget1");
    exit(1);
  }
  printf("shmid is %d\n", shmid);

  if((shmid2 = shmget(SHMKEY2, sizeof(int)*nAvatars*mazeWidth*mazeHeight, IPC_CREAT | 0666)) < 0 ){
    printf("avatar %d shmget2\n", avatarID);
    perror("shmget2");
    exit(1);
  }
  printf("shmid2 is %d\n", shmid2);

  /* avatar 0 initializes the shared memory */
  if (avatarID == 0){
    shmaze = shmat( shmid, (void *)0, 0);
    if( shmaze == (MazeNode *)(-1)){
      perror("shmat");
      exit(1);
    }

    trail = shmat( shmid2, (void *)0, 0);
    if( trail == (int *)(-1)){
      perror("shmat");
      exit(1);
    }
    
    int y;
    int x;
    for(y = 0; y < mazeHeight; y++){
      for(x = 0; x < mazeWidth; x++){
	/* intialize the maze info */
	(shmaze + y*mazeWidth + x)->north = 1;
        (shmaze + y*mazeWidth + x)->south = 1;
	(shmaze + y*mazeWidth + x)->east= 1;
	(shmaze + y*mazeWidth + x)->west= 1;
	(shmaze + y*mazeWidth + x)->pos.x = x;
	(shmaze + y*mazeWidth + x)->pos.y = y;
	for (int k = 0; k < nAvatars; k ++ ){
	  /* initialize the trail info */
	  *(trail + y*mazeWidth*nAvatars + x*nAvatars + k) = 0;
	}
      }
    }

    /* detaching shared memory */
    shmdt(trail);
    shmdt(shmaze);
  }
  
  /* for all avatars, attach shared memory */
  shmaze = shmat( shmid, (void *)0, 0);
  if( shmaze == (MazeNode *)(-1)){
    perror("shmat");
    exit(1);
  }

  trail = shmat( shmid2, (void *)0, 0);
  if( trail == (int *)(-1)){
    perror("shmat");
    exit(1);
  }
  /* individual maze */
  MazeNode ***maze = initMaze(mazeWidth, mazeHeight, nAvatars, avatarID);

  while (turns >= 0){

    /* attach shared memory */

    /* get the message from the server */
    if (recv(sockfd, &messageFromServer, sizeof(messageFromServer), 0) == 0){
      //error: server terminated prematurely
      perror("The server terminated prematurely");

      /* delete shared memory!!!! */
      exit(4);
    }

    else if(IS_AM_ERROR(messageFromServer.type)){
      perror("An error message was returned");

      /* delete shared memory!!!! */
      exit(5);
    }
    
    switch(ntohl(messageFromServer.type)){
      
    case AM_MAZE_SOLVED:

      if (avatarID == 0){

	printf("Maze solved in %d turns\n", turns);
	char *finishLine = calloc(strlen(fileName) + 60, sizeof(char));
	snprintf(finishLine, strlen(fileName) + 60, "echo -ne \"\nMaze solved in %d turns\n\" >> %s", turns, fileName);
	system(finishLine);
	free(finishLine);

        char *hashLine = calloc(strlen(fileName) + 60, sizeof(char));
        snprintf(hashLine, strlen(fileName) + 60, "echo -ne \"Hash: %ul\n\" >> %s", ntohl(messageFromServer.maze_solved.Hash), fileName);
        system(hashLine);
        free(hashLine);
	
	if (shmdt(shmaze) == -1){
	  perror("shmdt");
	  exit(1);
	}
	shmdt(trail);	
	/* deallocate shared memory */
	shmctl(shmid, IPC_RMID, 0);
	shmctl(shmid2, IPC_RMID, 0);
      }

      /* if it's not avatar 0, simply detach memory */
      else{
        if (shmdt(shmaze) == -1){
	  perror("shmdt");
          exit(1);
        }
        if(shmdt(trail) == -1) {
	  perror("shmdt");
	  exit(1);
	}

      }

      turns = -1;
      break;
      
    case AM_TOO_MANY_MOVES:
      if (avatarID == 0){
        printf("Maze failed in %d turns\n", turns);
        char *failedLine = calloc(strlen(fileName) + 60, sizeof(char));
        snprintf(failedLine, strlen(fileName) + 60, "echo -ne \"\nMaze failed in %d turns\n\" >> %s", turns, fileName);
        system(failedLine);
        free(failedLine);

	shmdt(shmaze);
	shmdt(trail);

	/* deallocate shared memory */
	shmctl(shmid, IPC_RMID, 0);
	shmctl(shmid2, IPC_RMID, 0);
      } 
      turns = -1;
      break;

    case AM_NO_SUCH_AVATAR:
      perror("No such avatar");
      break;

    case AM_UNKNOWN_MSG_TYPE:
      perror("Unknown message type");
      break;
      
    case AM_SERVER_TIMEOUT:
      perror("Server timed out");
      break;

    case AM_SERVER_DISK_QUOTA:
      perror("Exceeded disk quota");
      break;

    case AM_SERVER_OUT_OF_MEM:
      perror("Server out of memory");
      break;

    case AM_AVATAR_OUT_OF_TURN:
      perror("Avatar out of turn");
      break;
      
    case AM_AVATAR_TURN:

      /* check to see if it is this avatar's turn */

      if( ntohl(messageFromServer.avatar_turn.TurnId) == avatarID ){

	/* if it's the first move, can't update the maze */
	if(firstMove){
	  /* figure out the master avatar */
	  masterXY.x = ntohl(messageFromServer.avatar_turn.Pos[0].x);
	  masterXY.y = ntohl(messageFromServer.avatar_turn.Pos[0].y);

          currXY.x = ntohl(messageFromServer.avatar_turn.Pos[avatarID].x);
          currXY.y = ntohl(messageFromServer.avatar_turn.Pos[avatarID].y);

	  prevXY.x = currXY.x;
	  prevXY.y = currXY.y;

	  firstMove = 0;
	}
	/* otherwise, update the maze */

	else{
	  currXY.x = ntohl(messageFromServer.avatar_turn.Pos[avatarID].x);
	  currXY.y = ntohl(messageFromServer.avatar_turn.Pos[avatarID].y);
	  MazeNode *current = maze[currXY.y][currXY.x];
	  MazeNode *shmcurrent = (shmaze + currXY.y*mazeWidth + currXY.x);// get current shared maze node


	  if(prevXY.x == currXY.x && prevXY.y == currXY.y){
	    //move denied by wall
      	    blocked = 0;
            deadend++;

	    updateMaze(maze, prevDir, currXY, blocked, mazeWidth, mazeHeight, avatarID);

	    /* update the shared memory maze */
	    updateShmaze(shmaze, prevDir, prevXY, blocked, mazeWidth, mazeHeight);
	    //if we are in a deadend drop a 2 if we have been here for more than 5
	    //turns then do a new calculated move (called stuck move)
	    if(currXY.x!= masterXY.x || currXY.y != masterXY.y){
	      if(deadend == 3){
		current->paths[avatarID] = 2;
		if(deadend > 5){
		  calculatedMove = 1;
		}
	      }
	      
	      //if we are surrounded by walls we 
	      //need to drop a 2 since we are at
	      //a dead end
	      int walls = 0;
	      if(!shmcurrent->west) walls++;
	      if(!shmcurrent->north) walls++;
	      if(!shmcurrent->south) walls++;
	      if(!shmcurrent->east) walls++;
	      if(walls == 3){
		current->paths[avatarID] = 2;
	      }
	    }
	    
	  }
	  else{
	    blocked = 1;
	    deadend = 0;

	    updateMaze(maze, prevDir, currXY, blocked, mazeWidth, mazeHeight, avatarID);

	    /* update the shared memory maze */
	    updateShmaze(shmaze, prevDir, prevXY, blocked, mazeWidth, mazeHeight);
	  }

	  /* was not blocked, leave a breadcrumb when leaving the mazeNode */
	  if(blocked == 1 && !firstMove){
	    if( maze[prevXY.y][prevXY.x]->paths[avatarID] == 0){
	      maze[prevXY.y][prevXY.x]->paths[avatarID] = 1;
	    }
	    else if( maze[prevXY.y][prevXY.x]->paths[avatarID] >= 1){
	      maze[prevXY.y][prevXY.x]->paths[avatarID] = 2;
	    }
	    
	    /* update the trail */
            if(*(trail + prevXY.y*mazeWidth*nAvatars + prevXY.x*nAvatars + avatarID) == 0){
              *(trail + prevXY.y*mazeWidth*nAvatars + prevXY.x*nAvatars + avatarID) = 1;
	    }
	    
	    else if(*(trail + prevXY.y*mazeWidth*nAvatars + prevXY.x*nAvatars + avatarID) >= 1){
	      *(trail + prevXY.y*mazeWidth*nAvatars + prevXY.x*nAvatars + avatarID) = 2;
	      
	    }
	  }
	  /* fix the junction issue */
	  if(maze[prevXY.y][prevXY.x]->paths[avatarID] == 2 && maze[currXY.y][currXY.x]->paths[avatarID] == 0){
            maze[prevXY.y][prevXY.x]->paths[avatarID] = 1;
          }

	  prevXY = currXY; // update the previous posXY
	  
	}

	/* print the maze */
	if (ntohl(messageFromServer.avatar_turn.TurnId) == 0 ){
          printASCII(shmaze, mazeWidth, mazeHeight, nAvatars, trail, masterXY);
        }

	
	/* get the new direction */
	
	int direction = getNextMove(maze, currXY, masterXY, avatarID, mazeHeight, mazeWidth, shmaze);

	uint32_t newDirection;
	char *newDirectionString;
	
	switch(direction){

	case M_SOUTH:
	  prevDir = newDirection = M_SOUTH;
	  newDirectionString = "SOUTH";
	  break;

	case M_NORTH:
	  prevDir = newDirection = M_NORTH;
          newDirectionString = "NORTH";
	  break;

	case M_WEST:
	  prevDir = newDirection = M_WEST;
          newDirectionString = "WEST";
	  break;

	case M_EAST:
	  prevDir = newDirection = M_EAST;
          newDirectionString = "EAST";
	  break;

	case -100:
	  //for debug purposes
	  printf("\n\nBROKEN\n\n");
	  printf("Avatar %d broke the algorithm at %d, %d on turn %d\n", avatarID, currXY.x, currXY.y, turns);
          printf("The path at that location was %d\n", maze[currXY.y][currXY.x]->paths[avatarID]);
          printf("The path at SOUTH was %d\n", maze[currXY.y+1][currXY.x]->paths[avatarID]);
          printf("The path at NORTH was %d\n", maze[currXY.y-1][currXY.x]->paths[avatarID]);
          printf("The path at EAST was %d\n", maze[currXY.y][currXY.x+1]->paths[avatarID]);
          printf("The path at WEST was %d\n", maze[currXY.y][currXY.x-1]->paths[avatarID]);


	  if (shmdt(shmaze) == -1){
	    perror("shmdt");
	    exit(1);
	  }
	  shmdt(trail);
	  /* deallocate shared memory */
	  shmctl(shmid, IPC_RMID, 0);
	  shmctl(shmid2, IPC_RMID, 0);

	  printf("Used stuck move: %d\n", stuck);

	  printf("\n\n%d\n\n", mazePort);

	  exit(5);

	  break;
	  
	default:
	  prevDir = newDirection = M_NULL_MOVE;
	  newDirectionString = "NULL";
	  
	}
	
	/* set up the move message */
	messageToServer.type = htonl(AM_AVATAR_MOVE);
	messageToServer.avatar_move.AvatarId = htonl(avatarID);
        messageToServer.avatar_move.Direction = htonl(newDirection);
	send(sockfd, &messageToServer, sizeof(messageToServer), 0);
	
        char *movelogLine = calloc(strlen(fileName) + 120, sizeof(char));
	snprintf(movelogLine, strlen(fileName) + 120, "echo -ne \"\n[Avatar %d] Turn %d: (%d, %d) AM_AVATAR_MOVE Direction: %s\" >> %s", avatarID, turns, prevXY.x, prevXY.y, newDirectionString, fileName);
        system(movelogLine);
	free(movelogLine);

      }  
      
      turns++;
      break;
      
    default:
      break;
    }
  }

  // print the MazePort for easy access //
  if(avatarID==0){
    printf("%d\n", mazePort);
  }
  free_maze(maze, mazeHeight, mazeWidth, nAvatars);  
  return 0;
}
